


       parameter (n=400,nz=20)
       implicit double precision (a-h,o-z)
       common /const/ rq0,dlnr,scal,ax
       common /cour/ c(n,n),ima(n,n)
       common /grid/ g(n,1:nz+1),r(n),e(n)
       common /kern/ ck(n,n),ec(n,n)
       common /sedi/ cfl(n),nsub(n),dtsub(n),dt,dz,g_acc(n),g_flux(2,n)

       subroutine trkern (isw)
       parameter (n=400,nz=20)
       implicit double precision (a-h,o-z)
       common /grid/ g(n,1:nz+1),r(n),e(n)
       common /kern/ ck(n,n),ec(n,n)
       common /veloc/ winf(n),rr(n)
       dimension cck(n,n)
       data pi/3.141592654/
c terminal velocity
        write (6,*) 'Call terminal velocity'
       call fallg
       if (isw.eq.0) then
c long kernel
          do j=1,n
          do i=1,j
             if(r(j).le.50.) then
                effi=4.5d-4 *r(j)*r(j)*
      &              (1.d0-3.d0/ ( max( 3.d0, dble( r(i) ) ) + 1.d-2 )   )
             else
                effi=1.d0
             endif
             cck(j,i)=pi*(rr(j)+rr(i))*(rr(j)+rr(i))*effi*
      &               abs(winf(j)-winf(i))
             cck(i,j)=cck(j,i)
           enddo
           enddo
       elseif (isw.eq.1) then

       subroutine effic
c collision efficiencies of hall kernel
       parameter (n=400,nz=20)
       implicit double precision (a-h,o-z)
       common /grid/ g(n,1:nz+1),r(n),e(n)
       common /kern/ ck(n,n),ec(n,n)
       dimension rat(21),r0(15),ecoll(15,21)
       data r0 /6.,8.,10.,15.,20.,25.,30.,40.,50.,
      &         60.,70.,100.,150.,200.,300./
       data rat /0.,0.05,0.1,0.15,0.2,0.25,0.3,0.35,0.4,0.45,0.5,
      &          0.55,0.6,0.65,0.7,0.75,0.8,0.85,0.9,0.95,1.0/
       data ecoll /
      &  0.001,0.001,0.001,0.001,0.001,0.001,0.001,0.001,0.001,0.001
      & ,0.001,0.001,0.001,0.001,0.001,0.003,0.003,0.003,0.004,0.005
      & ,0.005,0.005,0.010,0.100,0.050,0.200,0.500,0.770,0.870,0.970
      & ,0.007,0.007,0.007,0.008,0.009,0.010,0.010,0.070,0.400,0.430
      & ,0.580,0.790,0.930,0.960,1.000,0.009,0.009,0.009,0.012,0.015
      & ,0.010,0.020,0.280,0.600,0.640,0.750,0.910,0.970,0.980,1.000
      & ,0.014,0.014,0.014,0.015,0.016,0.030,0.060,0.500,0.700,0.770
      & ,0.840,0.950,0.970,1.000,1.000,0.017,0.017,0.017,0.020,0.022
      & ,0.060,0.100,0.620,0.780,0.840,0.880,0.950,1.000,1.000,1.000
      & ,0.030,0.030,0.024,0.022,0.032,0.062,0.200,0.680,0.830,0.870
      & ,0.900,0.950,1.000,1.000,1.000,0.025,0.025,0.025,0.036,0.043
      & ,0.130,0.270,0.740,0.860,0.890,0.920,1.000,1.000,1.000,1.000
      & ,0.027,0.027,0.027,0.040,0.052,0.200,0.400,0.780,0.880,0.900
      & ,0.940,1.000,1.000,1.000,1.000,0.030,0.030,0.030,0.047,0.064
      & ,0.250,0.500,0.800,0.900,0.910,0.950,1.000,1.000,1.000,1.000
      & ,0.040,0.040,0.033,0.037,0.068,0.240,0.550,0.800,0.900,0.910
      & ,0.950,1.000,1.000,1.000,1.000,0.035,0.035,0.035,0.055,0.079
      & ,0.290,0.580,0.800,0.900,0.910,0.950,1.000,1.000,1.000,1.000
      & ,0.037,0.037,0.037,0.062,0.082,0.290,0.590,0.780,0.900,0.910
      & ,0.950,1.000,1.000,1.000,1.000,0.037,0.037,0.037,0.060,0.080
      & ,0.290,0.580,0.770,0.890,0.910,0.950,1.000,1.000,1.000,1.000
      & ,0.037,0.037,0.037,0.041,0.075,0.250,0.540,0.760,0.880,0.920
      & ,0.950,1.000,1.000,1.000,1.000,0.037,0.037,0.037,0.052,0.067
      & ,0.250,0.510,0.770,0.880,0.930,0.970,1.000,1.000,1.000,1.000
      & ,0.037,0.037,0.037,0.047,0.057,0.250,0.490,0.770,0.890,0.950
      & ,1.000,1.000,1.000,1.000,1.000,0.036,0.036,0.036,0.042,0.048
      & ,0.230,0.470,0.780,0.920,1.000,1.020,1.020,1.020,1.020,1.020
      & ,0.040,0.040,0.035,0.033,0.040,0.112,0.450,0.790,1.010,1.030
      & ,1.040,1.040,1.040,1.040,1.040,0.033,0.033,0.033,0.033,0.033
      & ,0.119,0.470,0.950,1.300,1.700,2.300,2.300,2.300,2.300,2.300
      & ,0.027,0.027,0.027,0.027,0.027,0.125,0.520,1.400,2.300,3.000
      & ,4.000,4.000,4.000,4.000,4.000/
c two-dimensional linear interpolation of the collision efficiency
       do j=1,n
       do i=1,j
          do k=2,15
             if (r(j).le.r0(k).and.r(j).ge.r0(k-1)) then
                ir=k
             elseif (r(j).gt.r0(15)) then
                ir=16
             elseif (r(j).lt.r0(1)) then
                ir=1
             endif
          enddo
          rq=r(i)/r(j)
          do kk=2,21
             if (rq.le.rat(kk).and.rq.gt.rat(kk-1)) iq=kk
          enddo
          if (ir.lt.16) then
             if (ir.ge.2) then
                p=(r(j)-r0(ir-1))/(r0(ir)-r0(ir-1))
                q=(rq-rat(iq-1))/(rat(iq)-rat(iq-1))
                ec(j,i)=(1.-p)*(1.-q)*ecoll(ir-1,iq-1)+
      &                 p*(1.-q)*ecoll(ir,iq-1)+
      &                 q*(1.-p)*ecoll(ir-1,iq)+
      &                 p*q*ecoll(ir,iq)
             else
                q=(rq-rat(iq-1))/(rat(iq)-rat(iq-1))
                ec(j,i)=(1.-q)*ecoll(1,iq-1)+q*ecoll(1,iq)
             endif
          else
             q=(rq-rat(iq-1))/(rat(iq)-rat(iq-1))
             ek=(1.-q)*ecoll(15,iq-1)+q*ecoll(15,iq)
             ec(j,i)=min(ek,1.d0)
          endif
          ec(i,j)=ec(j,i)
          if (ec(i,j).lt.1.e-20) stop 99
       enddo
       enddo

c     open (99,file='Efficiency_Hallkernel.out') !,status='old')
c       write (99,*) r
c       write (99,*) ec
c      close (99)
       return
       end

c hall kernel
          call effic
          do j=1,n
          do i=1,j
             cck(j,i)=pi*(rr(j)+rr(i))*(rr(j)+rr(i))*ec(j,i)*
      &               abs(winf(j)-winf(i))
             cck(i,j)=cck(j,i)
          enddo
          enddo
       else
c golovin kernel
          do j=1,n
          do i=1,j
             cck(j,i)=1.5*(e(j)+e(i))
             cck(i,j)=cck(j,i)
          enddo
          enddo
       endif
c two-dimensional linear interpolation of kernel
c         ! das ist unglücklich ausgedrückt: die Kernelwerte werden
lediglich geglättet.
c         ! Der Kernel wird sicherlich nicht an bestimmte Stelle durch
Interpolation ausgewertet!
       do i=1,n
       do j=1,n
          jm=max0(j-1,1)
          im=max0(i-1,1)
          jp=min0(j+1,n)
          ip=min0(i+1,n)
          ck(i,j)=0.125*(cck(i,jm)+cck(im,j)+cck(ip,j)+cck(i,jp))
      &           +.5*cck(i,j)
          if (i.eq.j) ck(i,j)=0.5*ck(i,j)
       enddo
       enddo
       return
       end

c Fallgeschw
       subroutine fallg

       parameter (n=400,nz=20)
       implicit double precision (a-h,o-z)
       common /grid/ g(n,1:nz+1),r(n),e(n)
       common /kern/ ck(n,n),ec(n,n)
       common /veloc/ winf(n),rr(n)
       dimension b(7),c(6),rat(20),r0(15),ecoll(15,20)
       data b /-0.318657e1,0.992696,-0.153193e-2,-0.987059e-3,
      &        -0.578878e-3,0.855176e-4,-0.327815e-5/
       data c /-0.500015e1,0.523778e1,-0.204914e1,0.475294,-0.542819e-1,
      &         0.238449e-2/
       data pi /3.141592654/
       eta=1.818e-4
       xlamb=6.62e-6
       rhow=1.
       rhoa=1.225e-3
       grav=980.665
       cunh=1.257*xlamb
       t0=273.15
       sigma=76.1-0.155*(293.15-t0)
       stok=2.*grav*(rhow-rhoa)/(9.*eta)
       stb=32.*rhoa*(rhow-rhoa)*grav/(3.*eta*eta)
       phy=sigma*sigma*sigma*rhoa*rhoa/((eta**4)*grav*(rhow-rhoa))
       py=phy**(1./6.)
c rr: radius in cm-units
       do j=1,n
          rr(j)=r(j)*1.e-4
       enddo
       do j=1,n
          if (rr(j).le.1.e-3) then
             winf(j)=stok*(rr(j)*rr(j)+cunh*rr(j))
          elseif (rr(j).gt.1.e-3.and.rr(j).le.5.35e-2) then
             x=log(stb*rr(j)*rr(j)*rr(j))
             y=0.
             do i=1,7
                y=y+b(i)*(x**(i-1))
             enddo
             xrey=(1.+cunh/rr(j))*exp(y)
             winf(j)=xrey*eta/(2.*rhoa*rr(j))
          elseif (rr(j).gt.5.35e-2) then
             bond=grav*(rhow-rhoa)*rr(j)*rr(j)/sigma
             if (rr(j).gt.0.35) bond=grav*(rhow-rhoa)*0.35*0.35/sigma
             x=log(16.*bond*py/3.)
             y=0.
             do i=1,6
                y=y+c(i)*(x**(i-1))
             enddo
             xrey=py*exp(y)
             winf(j)=xrey*eta/(2.*rhoa*rr(j))
             if (rr(j).gt.0.35)  winf(j)=xrey*eta/(2.*rhoa*0.35)
          endif
       enddo

        open (99,file='VBeard.out') !,status='old')
        write (99,*) 'n, (r(i),m(i),v(i))  in  (um,mg,cm/s)'
        write(99,*) n
        do i=1,400
        write (99,*) r(i),e(i), winf(i)
        enddo
       close (99)
             return
       end
